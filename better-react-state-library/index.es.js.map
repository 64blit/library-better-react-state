{"version":3,"file":"index.es.js","sources":["../node_modules/zustand/esm/middleware.mjs","../src/StoreUitls.ts","../src/AppStore.ts","../src/index.ts"],"sourcesContent":["const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...args) => api.dispatch(...args), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst removeStoreFromTrackedConnections = (name, store) => {\n  if (store === void 0) return;\n  const connectionInfo = trackedConnections.get(name);\n  if (!connectionInfo) return;\n  delete connectionInfo.stores[store];\n  if (Object.keys(connectionInfo.stores).length === 0) {\n    trackedConnections.delete(name);\n  }\n};\nconst findCallerName = (stack) => {\n  var _a, _b;\n  if (!stack) return void 0;\n  const traceLines = stack.split(\"\\n\");\n  const apiSetStateLineIndex = traceLines.findIndex(\n    (traceLine) => traceLine.includes(\"api.setState\")\n  );\n  if (apiSetStateLineIndex < 0) return void 0;\n  const callerLine = ((_a = traceLines[apiSetStateLineIndex + 1]) == null ? void 0 : _a.trim()) || \"\";\n  return (_b = /.+ (.+) .+/.exec(callerLine)) == null ? void 0 : _b[1];\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const inferredActionType = findCallerName(new Error().stack);\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || inferredActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  api.devtools = {\n    cleanup: () => {\n      if (connection && typeof connection.unsubscribe === \"function\") {\n        connection.unsubscribe();\n      }\n      removeStoreFromTrackedConnections(options.name, store);\n    }\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && args[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...args);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format.\n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState) return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, fn) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0) fn(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nfunction combine(initialState, create) {\n  return (...args) => Object.assign({}, initialState, create(...args));\n}\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(name, JSON.stringify(newValue, options == null ? void 0 : options.replacer)),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst persistImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            const migration = options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n            if (migration instanceof Promise) {\n              return migration.then((result) => [true, result]);\n            }\n            return [true, migration];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, void 0];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","// @refresh reset\n// ======= COMMON TYPES =======\n\n\n// ======= STORE SLICE ARCHITECTURE =======\n\n// Base state interface for all slices\nexport interface BaseState {\n  status: Record<string, string>\n  error: any\n  initialized: boolean\n  version: number\n}\n\n// Each slice creates and manages its own controllers\nexport type SliceControllers = Record<string, any>\n\n// Common slice interface with standard methods\nexport interface StoreSlice<T extends BaseState, C = SliceControllers> {\n  name: string\n  state: T\n  controllers: C\n  getState: () => T\n  setState: (state: Partial<T>) => void\n  update: () => void\n  setError: (error: any) => void\n  reset: () => void\n  setup: (initObject?: any) => Promise<void>\n  persist?: { blacklist?: (keyof T)[]; whitelist?: (keyof T)[] }\n  dependencies?: string[]\n}\n\n// Middleware configuration for persistence\nexport interface PersistOptions {\n  name: string\n  partialize?: (state: any) => any\n}\n\n// ======= SLICE CREATORS =======\n\n// Generic slice creator function\n/**\n * Creates a store slice with state management and controller setup\n *\n * @template T - The state type that extends BaseState\n * @template C - The controllers type (defaults to SliceControllers) - the controllers manage logic for the slice\n *\n * @param {T} initialState - The initial state for the slice\n * @param {string} sliceName - The name of the slice in the store\n * @param {Function} setupControllers - Async function to initialize controllers which handle all logic for the slice\n *\n * @returns {Function} A function that creates a StoreSlice with the following properties:\n * - state: The current state of the slice\n * - controllers: The initialized controllers for the slice\n * - getState: Function to get the current state\n * - setState: Function to update the state\n * - update: Function to trigger a store update\n * - setError: Function to set error state\n * - reset: Function to reset the slice to initial state\n * - setup: Async function to initialize the slice with session data\n *\n * @example\n * const reportSlice = createStoreSlice(\n *   initialReportState,\n *   'report',\n *   async (update, getState, setState, session) => {\n *     // Initialize controllers here\n *     return controllers;\n *   }\n * );\n */\n\nexport interface CreateSliceOptions<T extends BaseState> {\n  persist?: { blacklist?: (keyof T)[]; whitelist?: (keyof T)[] }\n  dependencies?: string[]\n}\n\nexport const createStoreSlice = <T extends BaseState, C = SliceControllers>(\n  initialState: T,\n  sliceName: string,\n  setupControllers: (\n    update: () => void,\n    get: () => any,\n    getState: () => T,\n    setState: (state: Partial<T>) => void,\n    initObject?: any\n  ) => Promise<C>,\n  options?: CreateSliceOptions<T>\n) => {\n  // returns a function that creates a StoreSlice\n  return (\n    set: (state: any) => void,\n    get: () => any,\n  ): StoreSlice<T, C> => {\n    const persist = options?.persist\n    const dependencies = options?.dependencies\n    // Slice update function\n    const update = () => {\n      set((state: any) => {\n        return {\n          version: state.version + 1,\n        }\n      })\n    }\n\n    // State getters and setters for this slice\n    const getSliceState = (): T => {\n      const state = get()\n      // During initialization, state[sliceName] might not exist yet\n      if (!state) {\n        return initialState as T\n      }\n\n      if (!state[sliceName]?.state) {\n        state[sliceName].state = initialState as T\n      }\n\n      return state[sliceName]?.state as T\n    }\n\n    const setSliceState = (newState: Partial<T>) => {\n      set((state: any) => {\n        const currentState = state[sliceName]\n        const currentSliceState = getSliceState()\n        const mergedState = { ...currentSliceState, ...newState }\n        const updatedSlice = { ...currentState, state: mergedState }\n        const nextVersion = state.version + 1\n        return { ...state, [sliceName]: updatedSlice, version: nextVersion }\n      })\n    }\n\n    // Slice controllers\n    let controllers: C = {} as C\n\n    // Setup the slice with initObject data and initialize controllers\n    const setup = async (initObject?: any): Promise<void> => {\n      // Always initialize controllers, even without initObject\n      controllers = await setupControllers(\n        update,\n        get,\n        getSliceState,\n        setSliceState,\n        initObject\n      )\n\n      set((state: any) => {\n        const newState = { ...state }\n        newState[sliceName] = { ...newState[sliceName] }\n        newState[sliceName].state = { ...newState[sliceName].state }\n        newState[sliceName].initialized = true\n        newState[sliceName].state.version = state.version + 1\n        newState[sliceName].controllers = controllers\n        return newState\n      })\n\n      return Promise.resolve()\n    }\n\n    const setError = (error: any) => {\n      setSliceState({\n        error,\n        status: {\n          ...getSliceState().status,\n          error: 'true',\n        },\n      } as unknown as Partial<T>)\n    }\n\n    const reset = () => {\n      setSliceState(initialState as unknown as Partial<T>)\n    }\n\n    const slice: StoreSlice<T, C> = {\n      name: sliceName,\n      state: initialState,\n      controllers,\n      update,\n      getState: getSliceState,\n      setState: setSliceState,\n      setError,\n      reset,\n      setup,\n      persist,\n      dependencies,\n    }\n\n    return slice\n  }\n}\n","// @refresh reset\n\nimport { create } from 'zustand'\nimport { devtools, persist } from 'zustand/middleware'\n\nimport {\n  type StoreSlice,\n  type BaseState,\n  type SliceControllers,\n  type CreateSliceOptions,\n  createStoreSlice\n} from './StoreUitls'\n\n\n// Re-export core types from StoreUitls for easier access\nexport type { BaseState, SliceControllers, CreateSliceOptions, StoreSlice }\n\n// // Session type used across the application\n// export type Session = {\n//   accessToken?: string\n//   expires?: string | Date\n//   accounts?: string[]\n//   owned_accounts?: string[]\n// }\n\n// export type ReportSession = Session // Keep for backward compatibility if needed\n\n// Simplified SliceConfig interface - users can specify exact state and controller types\nexport interface SliceConfig<TState extends BaseState = BaseState, TControllers = SliceControllers> {\n  name: string\n  create: (\n    set: any,\n    get: any,\n    api: any,\n    options?: CreateSliceOptions<TState>\n  ) => StoreSlice<TState, TControllers>\n  options?: CreateSliceOptions<TState>\n}\n\n// Configuration for the App Store - simplified approach\nexport interface AppStoreConfig {\n  name: string // Name for persistence\n  slices: SliceConfig<any, any>[] // Array of slice configurations\n  onSave?: (state: any) => Promise<void> // Optional callback for server-side saving\n}\n\n// ======= APP STORE ARCHITECTURE =======\n\n// Root app state combines all slice states\nexport interface AppRootState {\n  initObject?: any\n  initialized: boolean\n  version: number\n  isInitializing: boolean\n  error: string | null\n}\n\n// App state combines root state with dynamically added slices\nexport type AppState = AppRootState & {\n  [key: string]: StoreSlice<any, any> // Dynamically added slices\n} & {\n  setup: (initObject?: any) => Promise<void>\n}\n\n// Initial app state\nconst initialAppState: AppRootState = {\n  initObject: null,\n  initialized: false,\n  version: 0,\n  isInitializing: false,\n  error: null,\n}\n\n// ======= ROOT STORE =======\n\n// Create the root store - simplified approach\nfunction createAppStore(config: AppStoreConfig): () => AppState {\n  const { name, slices, onSave } = config\n\n  // Create the Zustand store\n  const useStore = create<AppState>()(\n    devtools(\n      persist(\n        (set, get, api) => {\n          // Dynamically create and register slices\n          const sliceMap: { [key: string]: StoreSlice<any, any> } = {}\n          slices.forEach((sliceConfig) => {\n            const slice = sliceConfig.create(set, get, api)\n            sliceMap[slice.name] = slice\n          })\n\n          // Setup function with proper error handling\n          const setup = async (initObject?: any) => {\n            const state = get()\n            if (state.initialized || state.isInitializing) return\n\n            set((state: AppState) => ({\n              ...state,\n              isInitializing: true,\n              initObject,\n              version: state.version + 1,\n            } as AppState))\n\n            try {\n              // Initialize slices in order\n              for (const sliceConfig of slices) {\n                const slice = sliceMap[sliceConfig.name]\n                if (slice && slice.setup) {\n                  await slice.setup(initObject)\n                }\n              }\n\n              set({\n                initialized: true,\n                isInitializing: false,\n                error: null,\n              } as Partial<AppState>)\n            } catch (error: any) {\n              console.error('Failed to initialize store slices:', error)\n              set({\n                isInitializing: false,\n                initialized: false,\n                error: `Initialization failed: ${error.message || 'Unknown error'}`,\n              } as Partial<AppState>)\n            }\n          }\n\n          // Subscribe to state changes for server-side save\n          if (onSave) {\n            api.subscribe((state: AppState) => {\n              if (!state.isInitializing && state.initialized && !state.error) {\n                onSave(state).catch((error) => {\n                  console.error('Failed to save state to server:', error)\n                })\n              }\n            })\n          }\n\n          // Create the store with proper slice integration\n          const returnStore = {\n            ...initialAppState,\n            ...sliceMap,\n            setup,\n          } as AppState\n\n          return returnStore\n        },\n        {\n          name: name,\n          // Implement selective partialize based on slice options\n          partialize: (state: AppState) => {\n            const persistedState: any = {}\n            slices.forEach((sliceConfig) => {\n              const slice = (state as any)[sliceConfig.name]\n              if (slice && sliceConfig.options?.persist) {\n                const sliceStateToPersist: any = {}\n                const stateKeys = Object.keys(slice.state)\n                if (sliceConfig.options.persist.whitelist) {\n                  sliceConfig.options.persist.whitelist.forEach((key) => {\n                    if (stateKeys.includes(key as string)) {\n                      sliceStateToPersist[key] = slice.state[key]\n                    }\n                  })\n                } else if (sliceConfig.options.persist.blacklist) {\n                  stateKeys.forEach((key) => {\n                    if (\n                      !sliceConfig?.options?.persist?.blacklist?.includes(\n                        key as any\n                      )\n                    ) {\n                      sliceStateToPersist[key] = slice.state[key]\n                    }\n                  })\n                } else {\n                  Object.assign(sliceStateToPersist, slice.state)\n                }\n                persistedState[sliceConfig.name] = {\n                  state: sliceStateToPersist,\n                }\n              }\n            })\n\n            return persistedState\n          },\n          // Implement selective merge based on slice options\n          merge: (persisted: any, current: AppState) => {\n            const mergedState = { ...current }\n            slices.forEach((sliceConfig) => {\n              const sliceName = sliceConfig.name\n              if (\n                persisted[sliceName]?.state &&\n                (mergedState as any)[sliceName]?.state\n              ) {\n                ;(mergedState as any)[sliceName].state = {\n                  ...(current as any)[sliceName].state,\n                  ...persisted[sliceName].state,\n                }\n              }\n            })\n\n            return mergedState\n          },\n        }\n      ),\n      {\n        name: name,\n        enabled: true,\n      }\n    )\n  )\n\n  return useStore as () => AppState\n}\n\nexport {\n  createAppStore,\n  createStoreSlice\n}\n","// Main entry point for better-react-state library\nexport { \n  type BaseState,\n  type SliceControllers,\n  createAppStore,\n  createStoreSlice,\n  type AppStoreConfig, \n  type SliceConfig, \n  type AppRootState, \n  type AppState\n} from './AppStore'\n\nexport {\n    type StoreSlice,\n    type PersistOptions,\n    type CreateSliceOptions\n} from './StoreUitls'\n\n// Import required types for utility functions\nimport type { \n  StoreSlice, \n  AppState, \n  AppStoreConfig, \n  SliceConfig, \n  BaseState, \n  SliceControllers \n} from './AppStore'\n\n// Utility functions for better developer experience\nexport function defineSliceConfig<TState extends BaseState, TControllers = SliceControllers>(\n  config: SliceConfig<TState, TControllers>\n): SliceConfig<TState, TControllers> {\n  return config\n}\n\nexport function defineStoreConfig(config: AppStoreConfig): AppStoreConfig {\n  return config\n} \n"],"names":["trackedConnections","getTrackedConnectionState","name","api","key","api2","extractConnectionInformation","store","extensionConnector","options","existingConnection","newConnection","removeStoreFromTrackedConnections","connectionInfo","findCallerName","stack","_a","_b","traceLines","apiSetStateLineIndex","traceLine","callerLine","devtoolsImpl","fn","devtoolsOptions","set","get","enabled","anonymousActionType","__vite_import_meta_env__","connection","connectionInformation","isRecording","state","replace","nameOrAction","r","inferredActionType","action","setStateFromDevtools","a","originalIsRecording","initialState","store2","didWarnAboutReservedActionType","originalDispatch","args","message","parseJsonThen","stateFromDevtools","nextLiftedState","lastComputedState","devtools","stringified","parsed","e","createJSONStorage","getStorage","storage","parse","str2","str","newValue","toThenable","input","result","onFulfilled","_onRejected","_onFulfilled","onRejected","persistImpl","config","baseOptions","persistedState","currentState","hasHydrated","hydrationListeners","finishHydrationListeners","setItem","savedSetState","configResult","stateFromStorage","hydrate","cb","_a2","postRehydrationCallback","deserializedStorageValue","migration","migrationResult","migrated","migratedState","newOptions","persist","createStoreSlice","sliceName","setupControllers","dependencies","update","getSliceState","setSliceState","newState","mergedState","updatedSlice","nextVersion","controllers","error","initObject","initialAppState","createAppStore","slices","onSave","create","sliceMap","sliceConfig","slice","setup","sliceStateToPersist","stateKeys","_c","persisted","current","defineSliceConfig","defineStoreConfig"],"mappings":"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","x_google_ignoreList":[0]}